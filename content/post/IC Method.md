---
title: "IC Method"
date: 2019-12-29
tags: ["strong", "methods"]
draft: false
---

## 1. Introduction

Let `$\hat{L}_{r}^{\mathrm{pc}} \in \mathbb{R}^{N \times r}$` and `$\hat{F}_{r}^{\mathrm{pc}} \in \mathbb{R}^{r \times T}$` be the PCA estimators for loadings and factors in the factor model. Define

`\begin{equation}
V(r)=\frac{1}{N T}\left\|Y-\hat{L}_{r}^{\mathrm{pc}} \hat{F}_{r}^{\mathrm{pc}}\right\|_{F}^{2},
\end{equation}`

and the following loss function:

 `\begin{equation} \label{eq:3.3}
     \mathrm{IC}(r) = V(r) + rg(N,T) \quad \text{or} \quad  \log (V(r)) + rg(N,T).
 \end{equation}`

The penalty function $g(N,T)$ satisfies two condition:

 * $g(N, T) \rightarrow 0$,
 * $C_{NT}^2 g(N,T)$ $\rightarrow \infty$,

 as $N, T \rightarrow \infty$, where $C_{NT} = \min \{\sqrt{N}, \sqrt{T}\}$.

Define the estimator for the number of factors as $\hat{r}$ $_{\mathrm{IC}}=\operatorname{argmin}_{0 \leq r \leq r_{max} } \mathrm{IC}(k).$ Then the consistency: $\hat{r}$ $_{\mathrm{IC}} \overset{p}{\rightarrow} r_{0}$ , as $N,T \rightarrow \infty$, can be established under strong factor assumption. Based on different forms of the penalty function $g(N,T)$, the loss function $IC(r)$ have different forms of criterions specifically:

* $IC1(r) = \mathrm{In}(V(r)) + r\;(\frac{N+T}{NT})\;\mathrm{In}(\frac{NT}{N+T})$;
* $IC2(r) = \mathrm{In}(V(r)) + r\;(\frac{N+T}{NT})\;\mathrm{In}C_{NT}^2$;
* $IC3(r) = \mathrm{In}(V(r)) + r\;(\frac{\mathrm{In}C_{NT}^2}{C_{NT}^2})$;
* $AIC3(r) = V(r) + r\; \hat{\sigma}^2\;(2\frac{(N+T -r)}{NT})$;
* $BIC3(r) = V(r) + r\; \hat{\sigma}^2\;(\frac{(N+T -r)\mathrm{In}(NT)}{NT})$.

For the details of this method, please refer [Bai and Ng, 2002](https://onlinelibrary.wiley.com/doi/abs/10.1111/1468-0262.00273).

## 2. R codes

Based on those forms, we can write the R code for the IC method as follow:

{{< highlight r >}}

IC <- function (X, rmax = NULL, criteria = NULL) {   # set up a function

  all(sapply(X, is.numeric) == TRUE) || stop("All columns must be numeric")

  is.xts(X) || stop("X must be an xts object so lags and differences are taken properly")

  if (!(rmax%%1 == 0)) {
    stop("rmax must be an integer.")
  }

  if (is.null(criteria)) {
    warning("criteria is NULL, setting criteria to BIC3")
    criteria <- "BIC3"
  }

  T <- dim(X)[1]  # column length of the imput matrix X
  N <- dim(X)[2]  # row length of the imput matrix X
  NT <- N * T
  NT1 <- N + T

  # construct a empty matrix for the vaules generated by penalty function
  CT <- matrix(0, 1, rmax)

  R <- seq(1: rmax) # sequence of r values
  C_NT <- min(N, T)

  # different criterions corresponding to different panelty forms
  if (criteria == "IC1") {      
    CT[1, ] <- log(NT/NT1) * R * NT1/NT
  }
  if (criteria == "IC2") {
    CT[1, ] <- (NT1/NT) * log(C_NT) * R
  }
  if (criteria == "IC3") {
    CT[1, ] <- R * log(C_NT)/C_NT
  }
  if (criteria == "AIC3") {
    CT[1, ] <- 2 * R * (NT1-R)/NT
  }
  if (criteria == "BIC3") {
    CT[1, ] <- log(NT) * R * (NT1-R)/NT
  }

  # construct a empty matrix for the values of the loss function IC(r)
  ic <- matrix(0, 1, rmax + 1)

  # construct a empty matrix for the loss function V(r)
  V <- matrix(0, 1, rmax + 1)  

  S <- t(X)%*%X                     # covariance matrix of X'X matrix
  eig <- eigen(S)$values            # correspoding eigenvalues
  eig_vec0 <- eigen(S)$vectors      # correspoding eigenvectors

  # try different r in the loss function IC(r)
  for (i in 1: rmax) {

    F_hat <- sqrt(T)*eig_vec0[, 1:i]     # PCA estimator for factors
    L_hat <- X%*%(F_hat)/T               # PCA estimator for Loadings


    e_hat = X - L_hat%*%t(F_hat)        # error terms

    V[i] <- sum(e_hat * e_hat/N*T)      # average values of loss function V(r)
    ic[,i] <- log(V[i]) + CT[, i]       # values of the loss function IC(r)
  }

  V[rmax + 1] <- sum(X * X/N*T)         # when r=0
  ic[,rmax + 1] <- log(V[rmax + 1])

  # select the minimum value of the loss function IC(r)
  ic_hat <- which.min(ic)    
  ic_hat <- ifelse(ic_hat <= rmax, ic_hat * 1, ic_hat * 0)

  output <- list(ic_hat = ic_hat, L_hat = L_hat, F_hat = F_hat)
  return(output)
}
{{< /highlight >}}

## 3. Strong factor estimation and robustness check

The only package we need to load before applying this function is:
{{< highlight r >}}
library(xts)
{{< /highlight >}}

Simulation design: consider <a id="DGP_strong"> a simple DGP </a> for generating strong factors with different types of noises as:

\begin{equation}
    Y_{it} = \sum_{j=1}^{r}\lambda_{ij} F_{tj}  + e_{it}, \quad \text{where}\\
    \lambda_{ij}, F_{tj} \stackrel{\text { iid }}{\sim} \mathcal{N}(0,1),\\
    \end{equation}
$$\text{with} \quad e_{i t} = \rho_{1} e_{i t-1} + (1-\rho_{1}^2)^{1/2} \xi_{it},$$
$$\text{and} \quad \xi_{i t} = \rho_{2} \xi_{i-1, t} + (1-\rho_{2}^2)^{1/2} \epsilon_{it}, \quad \epsilon_{it} \stackrel{\text { iid }}{\sim} \mathcal{N}(0,1).$$

We let $r=5$,  and consider the three cases for $e_{it}$ below:

  * **Case I:**   high serial correlation only, $\rho_{1} = 0.9$ and $\rho_{2} = 0$;

  * **Case II:**  high cross-sectional correlation only, $\rho_{1} = 0$ and $\rho_{2} = 0.8$;

  * **Case III:** non-guassion distributions only, $\rho_{1} = \rho_{2} = 0$. For example, we can chosse gamma distribution for $e_{it}$ with mean zero and variance 0.5.

The corresponding R code of applying the IC method using `IC2` criteria for this DGP is:

{{<highlight r>}}

S <- 10                   # Number of Simulation
N_set <- c(50, 100)
T_set <- c(50, 100, 200)
NT_comb <- expand.grid(N_set, T_set)  # Combination of N and T pairs

r_hat_IC <- matrix(NA, S, 4)

Factor_IC <- matrix(NA, nrow(NT_comb), 6)
colnames(Factor_IC) <- c("N","T", "white", "serial", "cross", "gamma")

r <- 5                    # Set the true number of factor

for(i in 1:nrow(NT_comb)){
  for(s in 1:S){

    # Data generating process
    N <- NT_comb[i,1]
    T <- NT_comb[i,2]

    F_0 <-  matrix(rnorm(T*r), T, r)  # Generating factor matrix
    L_0 <-  matrix(rnorm(N*r), N, r)  # Generating loading matrix

    # DGP for generating strong factors in white noise
    e_0 <-  matrix(rnorm(N*T), N, T)  
    X <- L_0%*%t(F_0) + e_0   

    # DGP for generating strong factors in high serially correlated noise
    rho1 <- 0.8
    e_1 <- matrix(NA, N, T)
    e_1[, 1] <- rnorm(N, 0, 1)

    for (t in 1:(T-1)) {
      e_1[, t+1] <- e_1[, t]*rho1 + sqrt(1 - rho1^2)*rnorm(N, 0, 1)
    }

    X1 <- L_0%*%t(F_0) + e_1


   # DGP for generating strong factors in high cross-sectionally correlated       noise
    rho2 <- 0.8
    e_2 <- matrix(NA, N, T)
    e_2[1,] <- rnorm(T, 0, 1)

    for (n in 1:(N-1)) {
      e_2[n+1 , ] <- e_2[n, ]*rho2 + sqrt(1 - rho2^2)*rnorm(T, 0, 1)
    }

    X2 <- L_0%*%t(F_0) + e_2

  # DGP for generating strong factors in noise with non-guassion distribution   # Take "Gamma" distributed noise as a example
  e_3 <-  matrix(rgamma(N * T, 0.25, scale = 4), nrow = N)
  X3 <- L_0%*%t(F_0) + e_3  

  # Apply any one of the criterions such as "IC2" to estimate
  # the number of strong factors in the DGP:    
  d <- as.Date(1:nrow(X))
  X.xts <- xts(X, order.by = d)
  r_hat_IC[s, 1] <- IC(X.xts, rmax = 16, "IC2")$ic

  d <- as.Date(1:nrow(X1))
  X1.xts <- xts(X1, order.by = d)
  r_hat_IC[s, 2] <- IC(X1.xts, rmax = 16, "IC2")$ic

  d <- as.Date(1:nrow(X2))
  X2.xts <- xts(X2, order.by = d)
  r_hat_IC[s, 3] <- IC(X2.xts, rmax = 16, "IC2")$ic

  d <- as.Date(1:nrow(X3))
  X3.xts <- xts(X3, order.by = d)
  r_hat_IC[s, 4] <- IC(X3.xts, rmax = 16, "IC2")$ic

  }
   Factor_IC[i,] <- c(N,T, colMeans(r_hat_IC))
}
{{< /highlight >}}

The results of the IC method using `IC2` criteria to estimate the number of strong factors with different types of error terms in the DGP are:

{{<highlight r>}}
      N   T  white serial cross gamma
[1,]  50  50     5   13.1  13.0   5.8
[2,] 100  50     5   15.6  13.8   5.7
[3,]  50 100     5   11.4  14.8   6.0
[4,] 100 100     5   14.1  14.9   6.0
[5,]  50 200     5    6.0  16.0   6.0
[6,] 100 200     5    8.3  16.0   6.0
{{< /highlight >}}

From the results above, we can see that the IC method is not robust when the error terms in the factor model are high serially and cross-sectionally correlated, or have gamma distribution.

## 4. Weak factor estimation

Besides, the IC method is designed to estimation the number of factors under strong factor assumption, so it may fail to detect weak factors in the data. To show this, let's apply the IC method to <a href="#DGP_weak"> the DGP </a> that we used to generate weak factors:


{{<highlight r>}}
Factor_IC_weak <- matrix(NA,nrow(NT_comb),3)
colnames(Factor_IC_weak) <- c("n","T","r_hat_IC")

for(i in 1:nrow(NT_comb)){
  for(s in 1:S){

  # Data generating process
  N <- NT_comb[i,1]
  T <- NT_comb[i,2]
  X <- DGP_weak(N,T,5)$Y  # DGP to generate weak factors

  # Apply any one of the criterions such as "IC1" to estimate
  # the number of strong factors in the DGP:    
  d <- as.Date(1:nrow(X))
  X.xts <- xts(X, order.by = d)
  r_hat_IC[s,] <- IC(X.xts, rmax = 16, "IC1")$ic

  }
   Factor_IC_weak[i,] <- c(N,T,mean(r_hat_IC))
}
{{< /highlight >}}

The goal is to estimation the number of strong and useful weak factors in the DGP. The results of the IC method using `IC2` criteria to estimate the number of weak factors in the DGP are:

{{<highlight r>}}
       N   T    r_hat
[1,]  50  50      2.9
[2,] 100  50      2.3
[3,]  50 100      2.1
[4,] 100 100      2.0
[5,]  50 200      2.0
[6,] 100 200      2.0
{{< /highlight >}}

The results above show that the IC method can estimate the number of strong and useful weak factors in the DGP quite well in finte samples, although it is not designed to estimate the number of weak factors.
